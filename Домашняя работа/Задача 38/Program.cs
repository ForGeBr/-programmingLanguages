/*Задача 38: Задайте массив вещественных чисел. 
Найдите разницу между максимальным и минимальным элементов массива.
[3 7 22 2 78] -> 76 */

/*C# поддерживает следующие предварительно определенные типы с плавающей запятой:

Ключевое слово или тип C#	Приблизительный диапазон значений	Точность	Размер	Тип .NET
float	От ±1,5 x 10−45 до ±3,4 x 1038	6–9 цифр	4 байта	System.Single
double	от ±5,0 × 10−324 до ±1,7 × 10308	15–17 цифр	8 байт	System.Double
decimal	от ±1,0 x 10-28 до ±7,9228 x 1028	28-29 знаков	16 байт	System.Decimal
В приведенной выше таблице каждый тип ключевого слова C# из крайнего левого столбца является псевдонимом для соответствующего типа .NET. Они взаимозаменяемые. Например, следующие объявления объявляют переменные одного типа:

C#

Копировать
double a = 12.3;
System.Double b = 12.3;
По умолчанию все типы с плавающей запятой имеют значение 0. Все типы с плавающей запятой имеют константы MinValue и MaxValue с минимальным и максимальными итоговыми значениями этого типа. Типы float и double также предоставляют константы, обозначающие бесконечные и нечисловые значения. Например, тип double предоставляет следующие константы: Double.NaN, Double.NegativeInfinity и Double.PositiveInfinity.

Тип decimal подходит, если требуемая степень точности определяется числом цифр справа от десятичной запятой. Такие числа обычно используются в финансовых приложениях для денежных сумм (например, 1,00 долл. США), процентных ставок (например, 2,625 %) и т. д. Даже числа, точные только до одной десятичной цифры, точнее обрабатываются типом decimal: 0,1, например, можно в точности представить экземпляром decimal. При этом не существует экземпляра double или float, который точно представляет 0,1. Из-за этой разницы в числовых типах в арифметических вычислениях могут возникать непредвиденные ошибки округления при использовании double или float для десятичных данных. Вы можете использовать double вместо decimal, если оптимизация производительности важнее, чем обеспечение точности. Но любая разница в производительности останется незамеченной для всех приложений, кроме самых требовательных к вычислениям. Еще одна возможная причина, по которой следует избегать decimal, — это минимальные требования к хранилищу. Например, ML.NET использует float, так как разница между 4 байтами и 16 байтами суммируется для очень больших наборов данных. Для получения дополнительной информации см. System.Decimal.

В одном и том же выражении можно сочетать и целочисленные типы, и типы float и double. В этом случае целочисленные типы неявно преобразуются в один из типов с плавающей запятой. При необходимости тип float неявно преобразуется в double. Выражение вычисляется следующим образом.

Если в выражении есть тип double, оно оценивается как double или bool в реляционных сравнениях или сравнениях на равенство.
Если в выражении нет типа double, оно оценивается как float или bool в реляционных сравнениях или сравнениях на равенство.
Можно также смешивать целочисленные типы и тип decimal в выражении. В этом случае целочисленные типы неявно преобразуются в тип decimal, а выражение вычисляется как decimal или bool в реляционных сравнениях и сравнениях на равенство.

Тип decimal нельзя смешивать с типами float и double в выражении. В этом случае, если требуется выполнить арифметические операции или операции сравнения или равенства, необходимо явно преобразовать операнды из типа или в тип decimal, как показано в следующем примере:

C#

double a = 1.0;
decimal b = 2.1m;
Console.WriteLine(a + (double)b);
Console.WriteLine((decimal)a + b);
Можно использовать строки стандартных числовых форматов или строки пользовательских числовых форматов для форматирования значения с плавающей запятой. */

Console.Clear();

double[] GetArray(int size, double minValue, double maxValue)
{
    double[] result = new double[size];
    for (int i = 0; i < size; i++)
    {
        result[i] = Math.Round(new Random().NextDouble() * (maxValue - minValue) + minValue, 2);
    }
    return result;
}

double ResultMax(double[] inArray)
{
    double max = inArray[0];
     double min = inArray[0];
    for (int i = 0; i < inArray.Length; i++)
    {
        if (inArray[i] > max)

            max = inArray[i];
    }
    return max;
}

double ResultMin(double[] inArray)
{
    double min = inArray[0];
    for (int i = 0; i < inArray.Length; i++)
    {
        if (inArray[i] < min)

            min = inArray[i];
    }
    return min;
}

double[] array = GetArray(5, 0, 10);
Console.WriteLine(String.Join(", ", array));
double min = ResultMin(array);
double max = ResultMax(array);
Console.WriteLine($"Максимальный элемент = {max}, Минимальный элемент массива = {min}");
Console.WriteLine($"Разница между максимальным и минимальным элементами = {Math.Round(max-min, 2)}");